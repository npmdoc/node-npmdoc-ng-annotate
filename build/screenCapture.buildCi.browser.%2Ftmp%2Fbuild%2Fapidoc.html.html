<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/olov/ng-annotate#readme">ng-annotate (v1.2.1)</a>
</h1>
<h4>add, remove and rebuild angularjs dependency injection annotations</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.ng-annotate">module ng-annotate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.ng-annotate">
            function <span class="apidocSignatureSpan"></span>ng-annotate
            <span class="apidocSignatureSpan">(src, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.lut">
            function <span class="apidocSignatureSpan">ng-annotate.</span>lut
            <span class="apidocSignatureSpan">(ast, src)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.pos_to_linecolumn">
            function <span class="apidocSignatureSpan">ng-annotate.</span>pos_to_linecolumn
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.scope">
            function <span class="apidocSignatureSpan">ng-annotate.</span>scope
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ng-annotate.</span>angular_dashboard_framework</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ng-annotate.</span>lut.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ng-annotate.</span>nginject</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ng-annotate.</span>pos_to_linecolumn.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ng-annotate.</span>scope.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ng-annotate.</span>scopetools</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ng-annotate.angular_dashboard_framework">module ng-annotate.angular_dashboard_framework</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.angular_dashboard_framework.init">
            function <span class="apidocSignatureSpan">ng-annotate.angular_dashboard_framework.</span>init
            <span class="apidocSignatureSpan">(_ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.angular_dashboard_framework.match">
            function <span class="apidocSignatureSpan">ng-annotate.angular_dashboard_framework.</span>match
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ng-annotate.lut">module ng-annotate.lut</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.lut.lut">
            function <span class="apidocSignatureSpan">ng-annotate.</span>lut
            <span class="apidocSignatureSpan">(ast, src)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ng-annotate.lut.prototype">module ng-annotate.lut.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.lut.prototype.findNodeBeforePos">
            function <span class="apidocSignatureSpan">ng-annotate.lut.prototype.</span>findNodeBeforePos
            <span class="apidocSignatureSpan">(pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.lut.prototype.findNodeFromPos">
            function <span class="apidocSignatureSpan">ng-annotate.lut.prototype.</span>findNodeFromPos
            <span class="apidocSignatureSpan">(pos)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ng-annotate.nginject">module ng-annotate.nginject</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.nginject.inspectComments">
            function <span class="apidocSignatureSpan">ng-annotate.nginject.</span>inspectComments
            <span class="apidocSignatureSpan">(ctx)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.nginject.inspectNode">
            function <span class="apidocSignatureSpan">ng-annotate.nginject.</span>inspectNode
            <span class="apidocSignatureSpan">(node, ctx)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ng-annotate.pos_to_linecolumn">module ng-annotate.pos_to_linecolumn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.pos_to_linecolumn.pos_to_linecolumn">
            function <span class="apidocSignatureSpan">ng-annotate.</span>pos_to_linecolumn
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ng-annotate.pos_to_linecolumn.prototype">module ng-annotate.pos_to_linecolumn.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.pos_to_linecolumn.prototype.toColumn">
            function <span class="apidocSignatureSpan">ng-annotate.pos_to_linecolumn.prototype.</span>toColumn
            <span class="apidocSignatureSpan">(pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.pos_to_linecolumn.prototype.toLine">
            function <span class="apidocSignatureSpan">ng-annotate.pos_to_linecolumn.prototype.</span>toLine
            <span class="apidocSignatureSpan">(pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.pos_to_linecolumn.prototype.toLineColumn">
            function <span class="apidocSignatureSpan">ng-annotate.pos_to_linecolumn.prototype.</span>toLineColumn
            <span class="apidocSignatureSpan">(pos)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ng-annotate.scope">module ng-annotate.scope</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.scope.scope">
            function <span class="apidocSignatureSpan">ng-annotate.</span>scope
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ng-annotate.scope.prototype">module ng-annotate.scope.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.scope.prototype.add">
            function <span class="apidocSignatureSpan">ng-annotate.scope.prototype.</span>add
            <span class="apidocSignatureSpan">(name, kind, node, referableFromPos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.scope.prototype.closestHoistScope">
            function <span class="apidocSignatureSpan">ng-annotate.scope.prototype.</span>closestHoistScope
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.scope.prototype.doesPropagate">
            function <span class="apidocSignatureSpan">ng-annotate.scope.prototype.</span>doesPropagate
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.scope.prototype.getFromPos">
            function <span class="apidocSignatureSpan">ng-annotate.scope.prototype.</span>getFromPos
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.scope.prototype.getKind">
            function <span class="apidocSignatureSpan">ng-annotate.scope.prototype.</span>getKind
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.scope.prototype.getNode">
            function <span class="apidocSignatureSpan">ng-annotate.scope.prototype.</span>getNode
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.scope.prototype.hasOwn">
            function <span class="apidocSignatureSpan">ng-annotate.scope.prototype.</span>hasOwn
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.scope.prototype.lookup">
            function <span class="apidocSignatureSpan">ng-annotate.scope.prototype.</span>lookup
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.scope.prototype.markPropagates">
            function <span class="apidocSignatureSpan">ng-annotate.scope.prototype.</span>markPropagates
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.scope.prototype.print">
            function <span class="apidocSignatureSpan">ng-annotate.scope.prototype.</span>print
            <span class="apidocSignatureSpan">(indent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.scope.prototype.remove">
            function <span class="apidocSignatureSpan">ng-annotate.scope.prototype.</span>remove
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ng-annotate.scopetools">module ng-annotate.scopetools</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.scopetools.isReference">
            function <span class="apidocSignatureSpan">ng-annotate.scopetools.</span>isReference
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ng-annotate.scopetools.setupScopeAndReferences">
            function <span class="apidocSignatureSpan">ng-annotate.scopetools.</span>setupScopeAndReferences
            <span class="apidocSignatureSpan">(root)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ng-annotate" id="apidoc.module.ng-annotate">module ng-annotate</a></h1>


    <h2>
        <a href="#apidoc.element.ng-annotate.ng-annotate" id="apidoc.element.ng-annotate.ng-annotate">
        function <span class="apidocSignatureSpan"></span>ng-annotate
        <span class="apidocSignatureSpan">(src, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ngAnnotate(src, options) {
    if (options.list) {
        return {
            list: Object.keys(allOptionals).sort(),
        };
    }

    var mode = (options.add &amp;&amp; options.remove ? "rebuild" :
        options.remove ? "remove" :
            options.add ? "add" : null);

    if (!mode) {
        return {src: src};
    }

    var quot = options.single_quotes ? "'" : '"';
    var re = (options.regexp ? new RegExp(options.regexp) : /^[a-zA-Z0-9_\$\.\s]+$/);
    var rename = new stringmap();
    if (options.rename) {
        options.rename.forEach(function(value) {
            rename.set(value.from, value.to);
        });
    }
    var ast;
    var stats = {};

    // detect newline and override os.EOL
    var lf = src.lastIndexOf("\n");
    if (lf &gt;= 1) {
        EOL = (src[lf - 1] === "\r" ? "\r\n" : "\n");
    }

    // [{type: "Block"|"Line", value: str, range: [from,to]}, ..]
    var comments = [];

    try {
        stats.parser_require_t0 = require_acorn_t0;
        stats.parser_require_t1 = require_acorn_t1;
        stats.parser_parse_t0 = Date.now();
        // acorn
        ast = parser(src, {
            ecmaVersion: 6,
            allowReserved: true,
            locations: true,
            ranges: true,
            onComment: comments,
        });
        stats.parser_parse_t1 = Date.now();
    } catch(e) {
        return {
            errors: ["error: couldn't process source due to parse error", e.message],
        };
    }

    // append a dummy-node to ast so that lut.findNodeFromPos(lastPos) returns something
    ast.body.push({
        type: "DebuggerStatement",
        range: [ast.range[1], ast.range[1]],
        loc: {
            start: ast.loc.end,
            end: ast.loc.end
        }
    });

    // all source modifications are built up as operations in the
    // fragments array, later sent to alter in one shot
    var fragments = [];

    // suspects is built up with suspect nodes by match.
    // A suspect node will get annotations added / removed if it
    // fulfills the arrayexpression or functionexpression look,
    // and if it is in the correct context (inside an angular
    // module definition)
    var suspects = [];

    // blocked is an array of blocked suspects. Any target node
    // (final, i.e. IIFE-jumped, reference-followed and such) included
    // in blocked will be ignored by judgeSuspects
    var blocked = [];

    // Position information for all nodes in the AST,
    // used for sourcemap generation
    var nodePositions = [];

    var lut = new Lut(ast, src);

    scopeTools.setupScopeAndReferences(ast);

    var ctx = {
        mode: mode,
        quot: quot,
        src: src,
        srcForRange: function(range) {
            return src.slice(range[0], range[1]);
        },
        re: re,
        rename: rename,
        comments: comments,
        fragments: fragments,
        suspects: suspects,
        blocked: blocked,
        lut: lut,
        isFunctionExpressionWithArgs: isFunctionExpressionWithArgs,
        isFunctionDeclarationWithArgs: isFunctionDeclarationWithArgs,
        isAnnotatedArray: isAnnotatedArray,
        addModuleContextDependentSuspect: addModuleContextDependentSuspect,
        addModuleContextIndependentSuspect: addModuleContextIndependentSuspect,
        stringify: stringify,
        nodePositions: nodePositions,
        matchResolve: matchResolve,
        matchProp: matchProp,
        last: last,
    };

    // setup optionals
    var optionals = options.enable || [];
    for (var i = 0; i &lt; optionals.length; i++) {
        var optional = String(optionals[i]);
        if (!allOptionals.hasOwnProperty(optional)) {
            return {
                errors: ["error: found no optional named " + optional],
            };
        }
    }
    var optionalsPlugins = optionals.map(function(optional) {
        return allOptionals[optional];
    });

    var plugins = [].concat(optionalsPlugins, options.plugin || []);

    function matchPlugins(node, isMethodCall) {
        for (var i = 0; i &lt; plugins.length; i++) {
            var res = plu ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ng-annotate.lut" id="apidoc.element.ng-annotate.lut">
        function <span class="apidocSignatureSpan">ng-annotate.</span>lut
        <span class="apidocSignatureSpan">(ast, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Lut(ast, src) {
    assert(this instanceof Lut);

    const sparseBegins = new Array(src.length);
    const begins = [];
    const sparseEnds = new Array(src.length);
    const ends = [];
    let p = 0;
    const t0 = Date.now();
    traverse(ast, {pre: function(node) {
        //        assert (node.range[0] &gt;= p);
        if (node.type === "Program") {
            return;
        }
        p = node.range[0];
        if (!sparseBegins[p]) {
            sparseBegins[p] = node;
        }
        p = node.range[1];
        if (!sparseEnds[p]) {
            sparseEnds[p] = node;
        }
    }});
    for (let i in sparseBegins) {
        begins.push(sparseBegins[i]);
    }
    for (let i in sparseEnds) {
        ends.push(sparseEnds[i]);
    }
    const t1 = Date.now();
    //    console.error(t1-t0)

    // begins and ends are compact arrays with nodes,
    // sorted on node.range[0/1] (unique)
    this.begins = begins;
    this.ends = ends;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ng-annotate.pos_to_linecolumn" id="apidoc.element.ng-annotate.pos_to_linecolumn">
        function <span class="apidocSignatureSpan">ng-annotate.</span>pos_to_linecolumn
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PosToLineColumn(str) {
    if (!(this instanceof PosToLineColumn)) {
        throw new Error("PosToLineColumn requires new");
    }
    str = String(str);

    const newlines = [];
    let pos = -1;
    while ((pos = str.indexOf("\n", pos + 1)) &gt;= 0) {
        newlines.push(pos);
    }

    let line = 1;
    let column = 0;
    const columns = [];
    const lines = [];
    let i;
    let j = 0;
    for (i = 0; i &lt; str.length; i++) {
        columns[i] = column;
        lines[i] = line;

        if (i === newlines[j]) {
            ++j;
            ++line;
            column = 0;
        } else {
            ++column;
        }
    }

    // add extra entry to support pos === str.length
    columns[i] = column;
    lines[i] = line;

    this.len = str.length;
    this.columns = columns;
    this.lines = lines;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ng-annotate.scope" id="apidoc.element.ng-annotate.scope">
        function <span class="apidocSignatureSpan">ng-annotate.</span>scope
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Scope(args) {
    assert(is.someof(args.kind, ["hoist", "block", "catch-block"]));
    assert(is.object(args.node));
    assert(args.parent === null || is.object(args.parent));

    // kind === "hoist": function scopes, program scope, injected globals
    // kind === "block": ES6 block scopes
    // kind === "catch-block": catch block scopes
    this.kind = args.kind;

    // the AST node the block corresponds to
    this.node = args.node;

    // parent scope
    this.parent = args.parent;

    // children scopes for easier traversal (populated internally)
    this.children = [];

    // scope declarations. decls[variable_name] = {
    //     kind: "fun" for functions,
    //           "param" for function parameters,
    //           "caught" for catch parameter
    //           "var",
    //           "const",
    //           "let"
    //     node: the AST node the declaration corresponds to
    //     from: source code index from which it is visible at earliest
    //           (only stored for "const", "let" [and "var"] nodes)
    // }
    this.decls = stringmap();

    // names of all variables declared outside this hoist scope but
    // referenced in this scope (immediately or in child).
    // only stored on hoist scopes for efficiency
    // (because we currently generate lots of empty block scopes)
    this.propagates = (this.kind === "hoist" ? stringset() : null);

    // scopes register themselves with their parents for easier traversal
    if (this.parent) {
        this.parent.children.push(this);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ng-annotate.angular_dashboard_framework" id="apidoc.module.ng-annotate.angular_dashboard_framework">module ng-annotate.angular_dashboard_framework</a></h1>


    <h2>
        <a href="#apidoc.element.ng-annotate.angular_dashboard_framework.init" id="apidoc.element.ng-annotate.angular_dashboard_framework.init">
        function <span class="apidocSignatureSpan">ng-annotate.angular_dashboard_framework.</span>init
        <span class="apidocSignatureSpan">(_ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (_ctx) {
    ctx = _ctx;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }
    return false;
}
const matchPluginsOrNull = (plugins.length === 0 ? null : matchPlugins);

ngInject.inspectComments(ctx);
plugins.forEach(function(plugin) {
    plugin.<span class="apidocCodeKeywordSpan">init</span>(ctx);
});

traverse(ast, {pre: function(node) {
    ngInject.inspectNode(node, ctx);

}, post: function(node) {
    ctx.nodePositions.push(node.loc.start);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ng-annotate.angular_dashboard_framework.match" id="apidoc.element.ng-annotate.angular_dashboard_framework.match">
        function <span class="apidocSignatureSpan">ng-annotate.angular_dashboard_framework.</span>match
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">match = function (node) {
    // dashboardProvider.widget("name", {
    //   ...
    //   controller: function($scope) {},
    //   resolve: {f: function($scope) {}, ..}
    // })

    const callee = node.callee;
    if (!callee) {
        return false;
    }

    const obj = callee.object;
    if (!obj) {
        return false;
    }

    // identifier or expression
    if (!(obj.$chained === 1 || (obj.type === "Identifier" &amp;&amp; obj.name === "dashboardProvider"))) {
        return false;
    }

    node.$chained = 1;

    const method = callee.property; // identifier
    if (method.name !== "widget") {
        return false;
    }

    const args = node.arguments;
    if (args.length !== 2) {
        return false;
    }

    const configArg = ctx.last(args);
    if (configArg.type !== "ObjectExpression") {
        return false;
    }

    const props = configArg.properties;
    const res = [
        ctx.matchProp("controller", props)
    ];
    // {resolve: ..}
    res.push.apply(res, ctx.matchResolve(props));

    // edit: {controller: function(), resolve: {}, apply: function()}
    const edit = ctx.matchProp('edit', props);
    if (edit &amp;&amp; edit.type === "ObjectExpression") {
        const editProps = edit.properties;
        res.push(ctx.matchProp('controller', editProps));
        res.push(ctx.matchProp('apply', editProps));
        res.push.apply(res, ctx.matchResolve(editProps));
    }

    const filteredRes = res.filter(Boolean);
    return (filteredRes.length === 0 ? false : filteredRes);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return allOptionals[optional];
});

const plugins = [].concat(optionalsPlugins, options.plugin || []);

function matchPlugins(node, isMethodCall) {
    for (let i = 0; i &lt; plugins.length; i++) {
        const res = plugins[i].<span class="apidocCodeKeywordSpan">match</span>(node, isMethodCall);
        if (res) {
            return res;
        }
    }
    return false;
}
const matchPluginsOrNull = (plugins.length === 0 ? null : matchPlugins);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ng-annotate.lut" id="apidoc.module.ng-annotate.lut">module ng-annotate.lut</a></h1>


    <h2>
        <a href="#apidoc.element.ng-annotate.lut.lut" id="apidoc.element.ng-annotate.lut.lut">
        function <span class="apidocSignatureSpan">ng-annotate.</span>lut
        <span class="apidocSignatureSpan">(ast, src)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Lut(ast, src) {
    assert(this instanceof Lut);

    const sparseBegins = new Array(src.length);
    const begins = [];
    const sparseEnds = new Array(src.length);
    const ends = [];
    let p = 0;
    const t0 = Date.now();
    traverse(ast, {pre: function(node) {
        //        assert (node.range[0] &gt;= p);
        if (node.type === "Program") {
            return;
        }
        p = node.range[0];
        if (!sparseBegins[p]) {
            sparseBegins[p] = node;
        }
        p = node.range[1];
        if (!sparseEnds[p]) {
            sparseEnds[p] = node;
        }
    }});
    for (let i in sparseBegins) {
        begins.push(sparseBegins[i]);
    }
    for (let i in sparseEnds) {
        ends.push(sparseEnds[i]);
    }
    const t1 = Date.now();
    //    console.error(t1-t0)

    // begins and ends are compact arrays with nodes,
    // sorted on node.range[0/1] (unique)
    this.begins = begins;
    this.ends = ends;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ng-annotate.lut.prototype" id="apidoc.module.ng-annotate.lut.prototype">module ng-annotate.lut.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.ng-annotate.lut.prototype.findNodeBeforePos" id="apidoc.element.ng-annotate.lut.prototype.findNodeBeforePos">
        function <span class="apidocSignatureSpan">ng-annotate.lut.prototype.</span>findNodeBeforePos
        <span class="apidocSignatureSpan">(pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findNodeBeforePos(pos) {
    const lut = this.ends;
    assert(is.finitenumber(pos) &amp;&amp; pos &gt;= 0);

    let left = 0;
    let right = lut.length - 1;
    while (left &lt; right) {
        const mid = Math.ceil((left + right) / 2);
        assert(mid &gt;= 0 &amp;&amp; mid &lt; lut.length);
        if (pos &lt; lut[mid].range[1]) {
            right = mid - 1;
        }
        else {
            left = mid;
        }
    }
    if (left &gt; right) {
        assert(lut[0].range[1] &gt; pos);
        return null;
    }

    const found = left;
    const foundPos = lut[found].range[1];
    if(foundPos &gt; pos) {
        return null;
    }
    if (found &lt;= lut.length - 2) {
        const nextPos = lut[found + 1].range[1];
        assert(nextPos &gt; pos);
    }

    return lut[found];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ng-annotate.lut.prototype.findNodeFromPos" id="apidoc.element.ng-annotate.lut.prototype.findNodeFromPos">
        function <span class="apidocSignatureSpan">ng-annotate.lut.prototype.</span>findNodeFromPos
        <span class="apidocSignatureSpan">(pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findNodeFromPos(pos) {
    const lut = this.begins;
    assert(is.finitenumber(pos) &amp;&amp; pos &gt;= 0);

    let left = 0;
    let right = lut.length - 1;
    while (left &lt; right) {
        const mid = Math.floor((left + right) / 2);
        assert(mid &gt;= 0 &amp;&amp; mid &lt; lut.length);
        if (pos &gt; lut[mid].range[0]) {
            left = mid + 1;
        }
        else {
            right = mid;
        }
    }
    if (left &gt; right) {
        assert(last(lut).range[0] &lt; pos);
        return null;
    }

    const found = left;
    const foundPos = lut[found].range[0];
    assert(foundPos &gt;= pos);
    if (found &gt;= 1) {
        const prevPos = lut[found - 1].range[0];
        assert(prevPos &lt; pos);
    }

    return lut[found];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    stats.parser_parse_t1 = Date.now();
} catch(e) {
    return {
        errors: ["error: couldn't process source due to parse error", e.message],
    };
}

// append a dummy-node to ast so that lut.<span class="apidocCodeKeywordSpan">findNodeFromPos</span>(lastPos) returns something
ast.body.push({
    type: "DebuggerStatement",
    range: [ast.range[1], ast.range[1]],
    loc: {
        start: ast.loc.end,
        end: ast.loc.end
    }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ng-annotate.nginject" id="apidoc.module.ng-annotate.nginject">module ng-annotate.nginject</a></h1>


    <h2>
        <a href="#apidoc.element.ng-annotate.nginject.inspectComments" id="apidoc.element.ng-annotate.nginject.inspectComments">
        function <span class="apidocSignatureSpan">ng-annotate.nginject.</span>inspectComments
        <span class="apidocSignatureSpan">(ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inspectComments(ctx) {
    const comments = ctx.comments;
    for (let i = 0; i &lt; comments.length; i++) {
        const comment = comments[i];
        const yesPos = comment.value.indexOf("@ngInject");
        const noPos = (yesPos === -1 ? comment.value.indexOf("@ngNoInject") : -1);
        if (yesPos === -1 &amp;&amp; noPos === -1) {
            continue;
        }

        const target = ctx.lut.findNodeFromPos(comment.range[1]);
        if (!target) {
            continue;
        }

        addSuspect(target, ctx, noPos &gt;= 0);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            return res;
        }
    }
    return false;
}
const matchPluginsOrNull = (plugins.length === 0 ? null : matchPlugins);

ngInject.<span class="apidocCodeKeywordSpan">inspectComments</span>(ctx);
plugins.forEach(function(plugin) {
    plugin.init(ctx);
});

traverse(ast, {pre: function(node) {
    ngInject.inspectNode(node, ctx);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ng-annotate.nginject.inspectNode" id="apidoc.element.ng-annotate.nginject.inspectNode">
        function <span class="apidocSignatureSpan">ng-annotate.nginject.</span>inspectNode
        <span class="apidocSignatureSpan">(node, ctx)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inspectNode(node, ctx) {
    if (node.type === "CallExpression") {
        inspectCallExpression(node, ctx);
    } else if (node.type === "FunctionExpression" || node.type === "FunctionDeclaration") {
        inspectFunction(node, ctx);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

ngInject.inspectComments(ctx);
plugins.forEach(function(plugin) {
    plugin.init(ctx);
});

traverse(ast, {pre: function(node) {
    ngInject.<span class="apidocCodeKeywordSpan">inspectNode</span>(node, ctx);

}, post: function(node) {
    ctx.nodePositions.push(node.loc.start);
    let targets = match(node, ctx, matchPluginsOrNull);
    if (!targets) {
        return;
    }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ng-annotate.pos_to_linecolumn" id="apidoc.module.ng-annotate.pos_to_linecolumn">module ng-annotate.pos_to_linecolumn</a></h1>


    <h2>
        <a href="#apidoc.element.ng-annotate.pos_to_linecolumn.pos_to_linecolumn" id="apidoc.element.ng-annotate.pos_to_linecolumn.pos_to_linecolumn">
        function <span class="apidocSignatureSpan">ng-annotate.</span>pos_to_linecolumn
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PosToLineColumn(str) {
    if (!(this instanceof PosToLineColumn)) {
        throw new Error("PosToLineColumn requires new");
    }
    str = String(str);

    const newlines = [];
    let pos = -1;
    while ((pos = str.indexOf("\n", pos + 1)) &gt;= 0) {
        newlines.push(pos);
    }

    let line = 1;
    let column = 0;
    const columns = [];
    const lines = [];
    let i;
    let j = 0;
    for (i = 0; i &lt; str.length; i++) {
        columns[i] = column;
        lines[i] = line;

        if (i === newlines[j]) {
            ++j;
            ++line;
            column = 0;
        } else {
            ++column;
        }
    }

    // add extra entry to support pos === str.length
    columns[i] = column;
    lines[i] = line;

    this.len = str.length;
    this.columns = columns;
    this.lines = lines;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ng-annotate.pos_to_linecolumn.prototype" id="apidoc.module.ng-annotate.pos_to_linecolumn.prototype">module ng-annotate.pos_to_linecolumn.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.ng-annotate.pos_to_linecolumn.prototype.toColumn" id="apidoc.element.ng-annotate.pos_to_linecolumn.prototype.toColumn">
        function <span class="apidocSignatureSpan">ng-annotate.pos_to_linecolumn.prototype.</span>toColumn
        <span class="apidocSignatureSpan">(pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toColumn = function (pos) {
    assert(pos &gt;= 0 &amp;&amp; pos &lt;= this.len);
    return this.columns[pos];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
assert(pos &gt;= 0 &amp;&amp; pos &lt;= this.len);
return this.columns[pos];
};

PosToLineColumn.prototype.toLineColumn = function(pos) {
return {
    line: this.toLine(pos),
    column: this.<span class="apidocCodeKeywordSpan">toColumn</span>(pos),
};
};


/*
const tst = "asdf\n" +
"abc\n" +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ng-annotate.pos_to_linecolumn.prototype.toLine" id="apidoc.element.ng-annotate.pos_to_linecolumn.prototype.toLine">
        function <span class="apidocSignatureSpan">ng-annotate.pos_to_linecolumn.prototype.</span>toLine
        <span class="apidocSignatureSpan">(pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toLine = function (pos) {
    assert(pos &gt;= 0 &amp;&amp; pos &lt;= this.len);
    return this.lines[pos];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
PosToLineColumn.prototype.toColumn = function(pos) {
    assert(pos &gt;= 0 &amp;&amp; pos &lt;= this.len);
    return this.columns[pos];
};

PosToLineColumn.prototype.toLineColumn = function(pos) {
    return {
        line: this.<span class="apidocCodeKeywordSpan">toLine</span>(pos),
        column: this.toColumn(pos),
    };
};


/*
const tst = "asdf\n" +
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ng-annotate.pos_to_linecolumn.prototype.toLineColumn" id="apidoc.element.ng-annotate.pos_to_linecolumn.prototype.toLineColumn">
        function <span class="apidocSignatureSpan">ng-annotate.pos_to_linecolumn.prototype.</span>toLineColumn
        <span class="apidocSignatureSpan">(pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toLineColumn = function (pos) {
    return {
        line: this.toLine(pos),
        column: this.toColumn(pos),
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const tst = "asdf\n" +
    "abc\n" +
    "d\n" +
    "\n\n" +
    "efghi a\r\n" +
    "x";
const instance = new PosToLineColumn(tst);
console.dir(instance.<span class="apidocCodeKeywordSpan">toLineColumn</span>(0));
console.dir(instance.toLineColumn(tst.length));
*/
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ng-annotate.scope" id="apidoc.module.ng-annotate.scope">module ng-annotate.scope</a></h1>


    <h2>
        <a href="#apidoc.element.ng-annotate.scope.scope" id="apidoc.element.ng-annotate.scope.scope">
        function <span class="apidocSignatureSpan">ng-annotate.</span>scope
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Scope(args) {
    assert(is.someof(args.kind, ["hoist", "block", "catch-block"]));
    assert(is.object(args.node));
    assert(args.parent === null || is.object(args.parent));

    // kind === "hoist": function scopes, program scope, injected globals
    // kind === "block": ES6 block scopes
    // kind === "catch-block": catch block scopes
    this.kind = args.kind;

    // the AST node the block corresponds to
    this.node = args.node;

    // parent scope
    this.parent = args.parent;

    // children scopes for easier traversal (populated internally)
    this.children = [];

    // scope declarations. decls[variable_name] = {
    //     kind: "fun" for functions,
    //           "param" for function parameters,
    //           "caught" for catch parameter
    //           "var",
    //           "const",
    //           "let"
    //     node: the AST node the declaration corresponds to
    //     from: source code index from which it is visible at earliest
    //           (only stored for "const", "let" [and "var"] nodes)
    // }
    this.decls = stringmap();

    // names of all variables declared outside this hoist scope but
    // referenced in this scope (immediately or in child).
    // only stored on hoist scopes for efficiency
    // (because we currently generate lots of empty block scopes)
    this.propagates = (this.kind === "hoist" ? stringset() : null);

    // scopes register themselves with their parents for easier traversal
    if (this.parent) {
        this.parent.children.push(this);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ng-annotate.scope.prototype" id="apidoc.module.ng-annotate.scope.prototype">module ng-annotate.scope.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.ng-annotate.scope.prototype.add" id="apidoc.element.ng-annotate.scope.prototype.add">
        function <span class="apidocSignatureSpan">ng-annotate.scope.prototype.</span>add
        <span class="apidocSignatureSpan">(name, kind, node, referableFromPos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (name, kind, node, referableFromPos) {
    assert(is.someof(kind, ["fun", "param", "var", "caught", "const", "let"]));

    function isConstLet(kind) {
        return is.someof(kind, ["const", "let"]);
    }

    let scope = this;

    // search nearest hoist-scope for fun, param and var's
    // const, let and caught variables go directly in the scope (which may be hoist, block or catch-block)
    if (is.someof(kind, ["fun", "param", "var"])) {
        while (scope.kind !== "hoist") {
//            if (scope.decls.has(name) &amp;&amp; isConstLet(scope.decls.get(name).kind)) { // could be caught
//                return error(getline(node), "{0} is already declared", name);
//            }
            scope = scope.parent;
        }
    }
    // name exists in scope and either new or existing kind is const|let =&gt; error
//    if (scope.decls.has(name) &amp;&amp; (isConstLet(scope.decls.get(name).kind) || isConstLet(kind))) {
//        return error(getline(node), "{0} is already declared", name);
//    }

    const declaration = {
        kind: kind,
        node: node,
    };
    if (referableFromPos) {
        assert(is.someof(kind, ["var", "const", "let"]));
        declaration.from = referableFromPos;
    }
    scope.decls.set(name, declaration);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Scope.prototype.doesPropagate = function(name) {
return this.propagates.has(name);
};

Scope.prototype.markPropagates = function(name) {
this.propagates.<span class="apidocCodeKeywordSpan">add</span>(name);
};

Scope.prototype.closestHoistScope = function() {
let scope = this;
while (scope.kind !== "hoist") {
    scope = scope.parent;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ng-annotate.scope.prototype.closestHoistScope" id="apidoc.element.ng-annotate.scope.prototype.closestHoistScope">
        function <span class="apidocSignatureSpan">ng-annotate.scope.prototype.</span>closestHoistScope
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">closestHoistScope = function () {
    let scope = this;
    while (scope.kind !== "hoist") {
        scope = scope.parent;
    }
    return scope;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // This is used to mark "taint" the name since adding a new variable in the scope,
    // with a propagated name, would change the meaning of the existing references.
    //
    // catch(e) is special because even though e is a variable in its own scope,
    // we want to make sure that catch(e){let e} is never transformed to
    // catch(e){var e} (but rather var e$0). For that reason we taint the use of e
    // in the closest hoist-scope, i.e. where var e$0 belongs.
    node.$scope.<span class="apidocCodeKeywordSpan">closestHoistScope</span>().markPropagates(identifier.name);

} else if (node.type === "Program") {
    // Top-level program is a scope
    // There's no block-scope under it
    node.$scope = new Scope({
        kind: "hoist",
        node: node,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ng-annotate.scope.prototype.doesPropagate" id="apidoc.element.ng-annotate.scope.prototype.doesPropagate">
        function <span class="apidocSignatureSpan">ng-annotate.scope.prototype.</span>doesPropagate
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doesPropagate = function (name) {
    return this.propagates.has(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ng-annotate.scope.prototype.getFromPos" id="apidoc.element.ng-annotate.scope.prototype.getFromPos">
        function <span class="apidocSignatureSpan">ng-annotate.scope.prototype.</span>getFromPos
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFromPos = function (name) {
    assert(is.string(name));
    const decl = this.decls.get(name);
    return decl ? decl.from : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ng-annotate.scope.prototype.getKind" id="apidoc.element.ng-annotate.scope.prototype.getKind">
        function <span class="apidocSignatureSpan">ng-annotate.scope.prototype.</span>getKind
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getKind = function (name) {
    assert(is.string(name));
    const decl = this.decls.get(name);
    return decl ? decl.kind : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

const scope = node.$scope.lookup(node.name);
if (!scope) {
    return null;
}

const parent = scope.getNode(node.name).$parent;
const kind = scope.<span class="apidocCodeKeywordSpan">getKind</span>(node.name);
if (!parent) {
    return null;
}
const ptype = parent.type;

if (is.someof(kind, ["const", "let", "var"])) {
    assert(ptype === "VariableDeclarator");
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ng-annotate.scope.prototype.getNode" id="apidoc.element.ng-annotate.scope.prototype.getNode">
        function <span class="apidocSignatureSpan">ng-annotate.scope.prototype.</span>getNode
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNode = function (name) {
    assert(is.string(name));
    const decl = this.decls.get(name);
    return decl ? decl.node : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

const scope = node.$scope.lookup(node.name);
if (!scope) {
    return null;
}

const parent = scope.<span class="apidocCodeKeywordSpan">getNode</span>(node.name).$parent;
const kind = scope.getKind(node.name);
if (!parent) {
    return null;
}
const ptype = parent.type;

if (is.someof(kind, ["const", "let", "var"])) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ng-annotate.scope.prototype.hasOwn" id="apidoc.element.ng-annotate.scope.prototype.hasOwn">
        function <span class="apidocSignatureSpan">ng-annotate.scope.prototype.</span>hasOwn
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasOwn = function (name) {
    return this.decls.has(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function createTopScope(programScope) {
function inject(obj) {
    for (let name in obj) {
        const writeable = obj[name];
        const kind = (writeable ? "var" : "const");
        if (topScope.<span class="apidocCodeKeywordSpan">hasOwn</span>(name)) {
            topScope.remove(name);
        }
        topScope.add(name, kind, {loc: {start: {line: -1}}}, -1);
    }
}

const topScope = new Scope({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ng-annotate.scope.prototype.lookup" id="apidoc.element.ng-annotate.scope.prototype.lookup">
        function <span class="apidocSignatureSpan">ng-annotate.scope.prototype.</span>lookup
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookup = function (name) {
    for (let scope = this; scope; scope = scope.parent) {
        if (scope.decls.has(name)) {
            return scope;
        } else if (scope.kind === "hoist") {
            scope.propagates.add(name);
        }
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

function followReference(node) {
if (!scopeTools.isReference(node)) {
    return null;
}

const scope = node.$scope.<span class="apidocCodeKeywordSpan">lookup</span>(node.name);
if (!scope) {
    return null;
}

const parent = scope.getNode(node.name).$parent;
const kind = scope.getKind(node.name);
if (!parent) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ng-annotate.scope.prototype.markPropagates" id="apidoc.element.ng-annotate.scope.prototype.markPropagates">
        function <span class="apidocSignatureSpan">ng-annotate.scope.prototype.</span>markPropagates
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">markPropagates = function (name) {
    this.propagates.add(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // This is used to mark "taint" the name since adding a new variable in the scope,
    // with a propagated name, would change the meaning of the existing references.
    //
    // catch(e) is special because even though e is a variable in its own scope,
    // we want to make sure that catch(e){let e} is never transformed to
    // catch(e){var e} (but rather var e$0). For that reason we taint the use of e
    // in the closest hoist-scope, i.e. where var e$0 belongs.
    node.$scope.closestHoistScope().<span class="apidocCodeKeywordSpan">markPropagates</span>(identifier.name);

} else if (node.type === "Program") {
    // Top-level program is a scope
    // There's no block-scope under it
    node.$scope = new Scope({
        kind: "hoist",
        node: node,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ng-annotate.scope.prototype.print" id="apidoc.element.ng-annotate.scope.prototype.print">
        function <span class="apidocSignatureSpan">ng-annotate.scope.prototype.</span>print
        <span class="apidocSignatureSpan">(indent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">print = function (indent) {
    indent = indent || 0;
    const scope = this;
    const names = this.decls.keys().map(function(name) {
        return fmt("{0} [{1}]", name, scope.decls.get(name).kind);
    }).join(", ");
    const propagates = this.propagates ? this.propagates.items().join(", ") : "";
    console.log(fmt("{0}{1}: {2}. propagates: {3}", fmt.repeat(" ", indent), this.node.type, names, propagates));
    this.children.forEach(function(c) {
        c.print(indent + 2);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const scope = this;
const names = this.decls.keys().map(function(name) {
    return fmt("{0} [{1}]", name, scope.decls.get(name).kind);
}).join(", ");
const propagates = this.propagates ? this.propagates.items().join(", ") : "";
console.log(fmt("{0}{1}: {2}. propagates: {3}", fmt.repeat(" ", indent), this.node.type, names, propagates));
this.children.forEach(function(c) {
    c.<span class="apidocCodeKeywordSpan">print</span>(indent + 2);
});
};

Scope.prototype.add = function(name, kind, node, referableFromPos) {
assert(is.someof(kind, ["fun", "param", "var", "caught", "const", "let"
;]));

function isConstLet(kind) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ng-annotate.scope.prototype.remove" id="apidoc.element.ng-annotate.scope.prototype.remove">
        function <span class="apidocSignatureSpan">ng-annotate.scope.prototype.</span>remove
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (name) {
    return this.decls.remove(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

Scope.prototype.hasOwn = function(name) {
    return this.decls.has(name);
};

Scope.prototype.remove = function(name) {
    return this.decls.<span class="apidocCodeKeywordSpan">remove</span>(name);
};

Scope.prototype.doesPropagate = function(name) {
    return this.propagates.has(name);
};

Scope.prototype.markPropagates = function(name) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ng-annotate.scopetools" id="apidoc.module.ng-annotate.scopetools">module ng-annotate.scopetools</a></h1>


    <h2>
        <a href="#apidoc.element.ng-annotate.scopetools.isReference" id="apidoc.element.ng-annotate.scopetools.isReference">
        function <span class="apidocSignatureSpan">ng-annotate.scopetools.</span>isReference
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isReference(node) {
    const parent = node.$parent;
    return node.$refToScope ||
        node.type === "Identifier" &amp;&amp;
            !(parent.type === "VariableDeclarator" &amp;&amp; parent.id === node) &amp;&amp; // var|let|const $
            !(parent.type === "MemberExpression" &amp;&amp; parent.computed === false &amp;&amp; parent.property === node) &amp;&amp; // obj.$
            !(parent.type === "Property" &amp;&amp; parent.key === node) &amp;&amp; // {$: ...}
            !(parent.type === "LabeledStatement" &amp;&amp; parent.label === node) &amp;&amp; // $: ...
            !(parent.type === "CatchClause" &amp;&amp; parent.param === node) &amp;&amp; // catch($)
            !(isFunction(parent) &amp;&amp; parent.id === node) &amp;&amp; // function $(..
            !(isFunction(parent) &amp;&amp; is.someof(node, parent.params)) &amp;&amp; // function f($)..
            true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        target.$seen = val;
        return true;
    });
}
}

function followReference(node) {
if (!scopeTools.<span class="apidocCodeKeywordSpan">isReference</span>(node)) {
    return null;
}

const scope = node.$scope.lookup(node.name);
if (!scope) {
    return null;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ng-annotate.scopetools.setupScopeAndReferences" id="apidoc.element.ng-annotate.scopetools.setupScopeAndReferences">
        function <span class="apidocSignatureSpan">ng-annotate.scopetools.</span>setupScopeAndReferences
        <span class="apidocSignatureSpan">(root)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setupScopeAndReferences(root) {
    traverse(root, {pre: createScopes});
    createTopScope(root.$scope);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// Position information for all nodes in the AST,
// used for sourcemap generation
const nodePositions = [];

const lut = new Lut(ast, src);

scopeTools.<span class="apidocCodeKeywordSpan">setupScopeAndReferences</span>(ast);

const ctx = {
    mode: mode,
    quot: quot,
    src: src,
    srcForRange: function(range) {
        return src.slice(range[0], range[1]);
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>